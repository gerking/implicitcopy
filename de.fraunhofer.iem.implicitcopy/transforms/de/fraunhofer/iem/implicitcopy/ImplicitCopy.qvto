library ImplicitCopy;

import de.fraunhofer.iem.implicitcopy.ImplicitCopyBlackbox;

modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';

property rootObject : EObject = null;
property allObjects : Collection(Element) = OrderedSet{};

helper Element :: create(context : OclAny) : Element {
		
	if (allObjects->excludes(self)) {
		return self;
	};
		
	var eClass : ecore::EClass := self.oclAsType(EObject).eClass();
	var factory : ecore::EFactory := eClass.ePackage.eFactoryInstance;
	return factory.create(eClass);
}

query Element :: getValues(feature : EStructuralFeature) : Sequence(OclAny) {
	
	var value = self.oclAsType(EObject).eGet(feature);
	
	if (feature.many) {
		return value.oclAsType(Sequence(OclAny));
	}
	elif (not value.oclIsUndefined()) {
		return Sequence{value};
	};
	
	return Sequence{};
}

mapping Element :: transform() : Element {
	init {
		var selfEObject := self.oclAsType(EObject);
	
		if (rootObject.oclIsUndefined()) {
			setRootElement(selfEObject);
		};
			
		if (result.oclIsUndefined()) {
			result := self.create(null);
		}
	}
	
	var eClass = selfEObject.eClass();
	var resultEObject = result.oclAsType(EObject);
	
	eClass.eAllReferences->select(r | r.isValidFeature(resultEObject))->forEach(r) {
		var sourceValues = self.getValues(r)[Element];
		var targetValues = sourceValues.map transform()[Element];
		setValues(resultEObject, r, targetValues);
	};
		
	eClass.eAllAttributes->select(a | a.isValidFeature(resultEObject))->forEach(a) {
		var values = self.getValues(a);
		setValues(resultEObject, a, values);
	};
	
	if (rootObject = self) {
		unsetRootElement();
	}
}

mapping Element :: transformWithContext(context : OclAny) : Element {
	init {
		var selfEObject := self.oclAsType(EObject);
	
		if (rootObject.oclIsUndefined()) {
			setRootElement(selfEObject);
		};
			
		if (result.oclIsUndefined()) {
			result := self.create(context);
		}
	}
	
	var eClass = selfEObject.eClass();
	var resultEObject = result.oclAsType(EObject);
	
	eClass.eAllReferences->select(r | r.isValidFeature(resultEObject))->forEach(r) {
		var sourceValues = self.getValues(r)[Element];
		var targetValues = sourceValues.map transformWithContext(context)[Element];
		setValues(resultEObject, r, targetValues);
	};
		
	eClass.eAllAttributes->select(a | a.isValidFeature(resultEObject))->forEach(a) {
		var values = self.getValues(a);
		setValues(resultEObject, a, values);
	};
	
	if (rootObject = self) {
		unsetRootElement();
	}
}

helper setRootElement(eObject : EObject) {
	rootObject := eObject;
	allObjects += rootObject;
	allObjects += rootObject.allSubobjects();
}

helper unsetRootElement() {
	rootObject := null;
	allObjects := OrderedSet{};
}

query EStructuralFeature :: isValidFeature(target : EObject) : Boolean {
	return self.changeable 
		and not self._derived 
		and not self.transient 
		and target.eClass().eAllStructuralFeatures->includes(self);
}
