library ImplicitCopy;

import org.muml.implicitcopy.qvto._library.ImplicitCopyBlackbox;

modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';

property root : EObject = null;
property allObjects : Collection(Element) = OrderedSet{};

helper Element::create(context : OclAny) : Element {
	if (allObjects->excludes(self)) {
		return self;
	};
		
	var eClass : ecore::EClass := self.oclAsType(EObject).eClass();
	var factory : ecore::EFactory := eClass.ePackage.eFactoryInstance;
	return factory.create(eClass);
}

query Element :: getValues(feature : EStructuralFeature) : Sequence(OclAny) {
	
	var value = self.oclAsType(EObject).eGet(feature);
	
	if (feature.many) {
		return value.oclAsType(Sequence(OclAny));
	}
	elif (not value.oclIsUndefined()) {
		return Sequence{value};
	};
	
	return Sequence{};
}

mapping Element :: transform() : Element {
	init {
		var selfEObject := self.oclAsType(EObject);
	
		if (root.oclIsUndefined()) {
			registerRootElement(selfEObject);
		};
			
		if (result.oclIsUndefined()) {
			result := self.create(null);
		}
	}
	
	var eClass = selfEObject.eClass();
	var resultEObject = result.oclAsType(EObject);
	
	eClass.eAllReferences->select(r | r.isValidFeature(resultEObject))->forEach(r) {
		var sourceValues = self.getValues(r)[Element];
		var targetValues = sourceValues.map transform()[Element];
		setValues(resultEObject, r, targetValues);
	};
		
	eClass.eAllAttributes->select(a | a.isValidFeature(resultEObject))->forEach(a) {
		var values = self.getValues(a);
		setValues(resultEObject, a, values);
	};
	
	if (root = self) {
		unregisterRootElement();
	}
}


mapping Element :: transformWithContext(context : OclAny) : Element {
	init {
		var selfEObject := self.oclAsType(EObject);
	
		if (root.oclIsUndefined()) {
			registerRootElement(selfEObject);
		};
			
		if (result.oclIsUndefined()) {
			result := self.create(context);
		}
	}
	
	var eClass = selfEObject.eClass();
	var resultEObject = result.oclAsType(EObject);
	
	eClass.eAllReferences->select(r | r.isValidFeature(resultEObject))->forEach(r) {
		var sourceValues = self.getValues(r)[Element];
		var targetValues = sourceValues.map transformWithContext(context)[Element];
		setValues(resultEObject, r, targetValues);
	};
		
	eClass.eAllAttributes->select(a | a.isValidFeature(resultEObject))->forEach(a) {
		var values = self.getValues(a);
		setValues(resultEObject, a, values);
	};
	
	if (root = self) {
		unregisterRootElement();
	}
}

helper registerRootElement(eObject : EObject) {
	root := eObject;
	allObjects += root;
	allObjects += root.allSubobjects();
}

helper unregisterRootElement() {
	root := null;
	allObjects := OrderedSet{};
}

query EStructuralFeature :: isValidFeature(target : EObject) : Boolean {
	return self.changeable 
		and not self._derived 
		and not self.transient 
		and target.eClass().eAllStructuralFeatures->includes(self);
}